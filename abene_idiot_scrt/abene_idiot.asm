; statement at start of IDIOT source code:
;-------------------------------------------------------------;
; IDIOT/4 MONITOR FOR THE 1802	 WRITTEN: 6/23/82 BY LEE HART ;
; COPYRIGHT 1982-85 BY TMSI	LAST MOD: 3/28/86 BY LEE HART ;
;							      ;
; This program may be used for any noncommercial use free of  ;
; charge. Contact information: Lee A. Hart, 814 8th Ave N,    ;
; Sartell MN 56377, email <leeahart@earthlink.net>	      ;
;-------------------------------------------------------------;
;
;fixes by Herb Johnson HRJ April 2010, Jan 2014
;
; register equivalents for A18
R0		EQU	0
R1		EQU	1
R2		EQU	2
R3		EQU	3
R4		EQU	4
R5		EQU	5
R6		EQU	6
R7		EQU	7
R8		EQU	8
R9		EQU	9
RA		EQU	10
RB		EQU	11
RC		EQU	12
RD		EQU	13
RE		EQU	14
RF		EQU	15
;
;
; REGISTER ASSIGNMENTS:
;
;		1 - INTERRUPT PROGRAM COUNTER (FOR BREAKPOINTS)
;		2 - STACK POINTER
;		3 - NORMAL PROGRAM COUNTER
;		4 - MONITOR: RAM PAGE0 POINTER
;		    BASIC:   SCRT "CALL" PC
;		5 - MONITOR: MAIN PC
;		    BASIC:   SCRT "RETURN" PC
;		8 - MONITOR: ?M VS. !M SWITCH
;	       10 - MONITOR: MEMORY POINTER
DELAY	EQU    12 ; PC FOR DELAY SUBROUTINE
HEXX	EQU    13 ; MONITOR: HEX ADDRESS ACCUMULATOR
BAUD	EQU    14 ; RE.1=BAUD RATE CONSTANT
;		    RE.0=USED FOR READ, TYPE
ASCII	EQU    15 ; RF.1=ASCII I/O CHARACTER
;		    RF.0=USED FOR READ, TYPE


;Mark Abene's additions and Herb's commentary Jan 20 2019
;

; IDIOT normally assembled at 0000H, but will run at any
; page boundary by on-the-fly fixing the one long-jump.

; calls to IDIOT assuming IDIOT assembled/run at 0000H

TYPE		EQU	01A4H		; SERIAL WRITES CHAR IN ASCII.1 (RF.1) 
READ		EQU	013EH		; READS A SERIAL CHAR RETURNS  ASCII CODE IN RF.1 and D 

	ORG 0400H		;essentially outside of the IDIOT ROM

;Mark Abene <phiber@phiber.com> Jan 20 2019:
;  added SCRT routines
;  read/write char/line routines


; The following routines have been added 
; by Mark Abene <phiber@phiber.com> in 1/2019,
; based in part on routines from Mike Riley's
; Micro Elf BIOS and adapted to IDIOTMON.
;
; SCRT: "SEP R4" "DW addr" is "CALL", "SEP R5" is "RETURN"
;
; INITIALIZE SCRT
;
INITCALL: LDI	HIGH RET
	PHI	R5
	LDI	LOW RET
	PLO	R5
	LDI	HIGH CALL
	PHI	R4
	LDI	LOW CALL
	PLO	R4
	SEP	R5
;
; SCRT CALL
;
	SEP	R3		; JUMP TO CALLED ROUTINE
CALL:	PLO	RE		; SAVE D
	GHI	R6		; SAVE LAST R6 TO STACK
	SEX	R2
	STXD
	GLO	R6
	STXD
	GHI	R3		; COPY R3 TO R6
	PHI	R6
	GLO	R3
	PLO	R6
	LDA	R6		; GET SUBROUTINE ADDRESS
	PHI	R3		; AND PUT INTO R3
	LDA	R6
	PLO	R3
	GLO	RE		; RECOVER D
	BR	CALL-1		; TRANSFER CONTROL TO SUBROUTINE
;
; SCRT RET
;
	SEP	R3		; TRANSFER CONTROL BACK TO CALLER
RET:	PLO	RE		; SAVE D
	GHI	R6		; COPY R6 TO R3
	PHI	R3
	GLO	R6
	PLO	R3
	SEX	R2
	IRX			; POINT TO OLD R6
	LDXA
	PLO	R6
	LDX
	PHI	R6
	GLO	RE
	BR	RET-1		; AND PERFORM RETURN TO CALLER
;
; DISPLAY CHARACTER IN D
;
F_TYPE	PLO	RE		; STASH D
	GLO	RD		; SAVE RD
	STXD
	GHI	RD
	STXD
	GLO	RE		; RESTORE D
	PHI	RF
	SEP	R4
	DW	TYPE
	IRX			; RESTORE RD
	LDXA
	PHI	RD
	LDX
	PLO	RD
	SEP	R5
;
; TYPE MESSAGE POINTED TO BY RA
;
F_MSG	LDA	RA
	BZ	RETURN
	SEP	R4
	DW	F_TYPE
	BR	F_MSG
RETURN	SEP	R5
;
; READ A KEY WITH ECHO, RETURNS IN D
;
F_READ	GLO	RD		; SAVE RD
	STXD
	GHI	RD
	STXD
	SEP	R4
	DW	READ		; IMPLIED ECHO
	PLO	RE		; STASH D
	IRX			; RESTORE RD
	LDXA
	PHI	RD
	LDX
	PLO	RD
	GLO RE			; RESTORE D
	SEP	R5
;
; READ A LINE INTO MAX 256-BYTE BUFFER POINTED TO BY RA
;
F_INPUT	GLO	R8		; SAVE R8, R9 AND RB
	STXD
	GHI	R8
	STXD
	GLO	R9
	STXD
	GHI	R9
	STXD
	GLO	RB
	STXD
	GHI	RB
	STXD
	LDI	1
	PHI	R8
	LDI	0
	PLO	R8
	LDI	0		; BYTE COUNT
	PLO	R9		; STORE INTO COUNTER
INPLP:	SEP	R4		; CALL INPUT FUNCTION
	DW	F_READ
  	PLO	RB		; SAVE CHAR
	SMI	3		; CHECK FOR <CTRL><C>
	BZ	INPTERM		; TERMINATE INPUT
	SMI	5		; CHECK FOR <BS>
	BZ	ISBS		; JUMP IF SO
	SMI	5		; CHECK FOR <CR>
	BZ	INPDONE		; JUMP IF SO
	GLO	R8		; CHECK COUNT
	BNZ	INPCNT		; JUMP IF CAN CONTINUE
	GHI	R8		; CHECK HIGH OF COUNT
	BNZ	INPCNT
	LDI	8		; PERFORM A BACKSPACE
	SEP	R4
	DW	F_TYPE
	BR	BS2		; REMOVE CHAR FROM SCREEN
INPCNT:	GLO	RB
	STR	RA		; STORE INTO OUTPUT
	INC	RA		; POINT TO NEXT POSITION
	SMI	08		; LOOK FOR BACKSPACE
	BNZ	NOBS		; JUMP IF NOT A BACKSPACE
ISBS:	GLO	R9		; GET INPUT COUNT
	BZ	INPLP		; DISREGARD IF STRING IS EMPTY
	DEC	R9		; DECREMENT THE COUNT
	DEC	RA		; DECREMENT BUFFER POSITION
	INC	R8		; INCREMENT ALLOWED CHARACTERS
BS2:	LDI	32		; DISPLAY A SPACE
	SEP	R4
	DW	F_TYPE
	LDI	8		; THEN BACKSPACE AGAIN
	SEP	R4
	DW	F_TYPE
	BR	INPLP		; AND LOOP BACK FOR MORE
NOBS:	INC	R9		; INCREMENT INPUT COUNT
	DEC	R8		; DECREMENT CHARACTER COUNT
	BR	INPLP		; AND THEN LOOP BACK
INPDONE: LDI	0		; NEED A ZERO TERMINATOR
	SHR			; RESET DF FLAG, TO SHOW VALID INPUT
INPDONE2: STR	RA		; STORE INTO BUFFER
INPTERM: IRX			; RECOVER RB AND R9
	LDXA
	PHI	RB
	LDXA
	PLO	RB
	LDXA
	PHI	R9
	LDXA
	PLO	R9
	LDXA
	PHI	R8
	LDX
	PLO	R8
	SEP	R5		; RETURN TO CALLER
	SMI	0		; SIGNAL <CTRL><C> EXIT
	LDI	0		; FINISH
	BR	INPDONE2

	END

